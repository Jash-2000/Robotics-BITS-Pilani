# -*- coding: utf-8 -*-
"""Main_Script.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PbnV9EXqgzIMvbQ7ctK_rlGZShUQJMCwr
"""

import intelligent_robotics as ir
import sympy
sympy.init_printing()

theta1,theta2 = ir.dynamicsymbols('theta1,theta2')

l1,l1g,l2,l2g,IG1,IG2,m1,m2 = sympy.symbols('l1,l1g,l2,l2g,IG1,IG2,m1,m2')

"""#### DH Parameter

"""

T01 = ir.DH(0,0,l1,theta1)

T12 = ir.DH(0,-sympy.rad(90),0,theta2)

T23 = ir.DH(l2,sympy.rad(90),0,0)

T01, T12, T23

w_0_0 = sympy.Matrix([[0],[0],[0]])
w_1_1 = ir.get_angular_vel_R(T01,w_0_0,theta1.diff())
w_2_2 = ir.get_angular_vel_R(T12,w_1_1,theta2.diff())
w_3_3 = ir.get_angular_vel_R(T23,w_2_2,0)

w_1_1,w_2_2,w_3_3

v_0_0 = sympy.Matrix([[0],[0],[0]])
v_1_1 = ir.get_linear_vel_R(T01,w_0_0,v_0_0)
v_2_2 = ir.get_linear_vel_R(T12,w_1_1,v_1_1)
v_3_3 = ir.get_linear_vel_R(T23,w_2_2,v_2_2)

v_1_1,v_2_2,v_3_3

qd = sympy.Matrix([[theta1.diff()],[theta2.diff()]])

J_3_3 = ir.get_Jacobian_from_vel(w_3_3,v_3_3,qd)

# Body Jacobian
J_3_3

w_0_3 = ir.get_R_from_T(T01*T12*T23)*w_3_3
v_0_3 = ir.get_R_from_T(T01*T12*T23)*v_3_3
J_0_3 = ir.get_Jacobian_from_vel(w_0_3,v_0_3,qd)

# Space Jacobian
J_0_3

"""### Dynamics"""

f_x, f_y, f_z = sympy.symbols('f_x, f_y, f_z')

f_3_3 = sympy.Matrix([[f_x],[f_y],[f_z]])
n_3_3 = sympy.Matrix([[0],[0],[0]])

f_2_2 = ir.get_statics_force_i(T23, f_3_3)
f_1_1 = ir.get_statics_force_i(T12, f_2_2)

f_2_2, f_1_1

n_2_2 = ir.get_statics_torque_i(T23, n_3_3, f_2_2)
n_1_1 = ir.get_statics_torque_i(T12, n_2_2, f_1_1)

n_2_2, n_1_1

T = sympy.Matrix([[n_1_1[2]],[n_2_2[2]]])
F = sympy.Matrix([[f_x],[f_y],[f_z]])

T, F

# T = J^T * F
# tau1           fx
# tau2  =  J^T * fy
# tau3           fz
Jt = ir.get_Jacobian_from_ft(F,T)

# 
J = Jt.T

# Body Jacobian
J

# Netwon-Euler Method. 1. Forward Iteration

w_0_0 = sympy.Matrix([[0],[0],[0]])
w_1_1 = ir.get_angular_vel_R(T01,w_0_0,theta1.diff())
w_2_2 = ir.get_angular_vel_R(T12,w_1_1,theta2.diff())
w_3_3 = ir.get_angular_vel_R(T23,w_2_2,0)
wd_0_0 = sympy.Matrix([[0],[0],[0]])
wd_1_1 = ir.get_angular_acc_R(T01,w_0_0,wd_0_0,theta1.diff(),theta1.diff().diff())
wd_2_2 = ir.get_angular_acc_R(T12,w_1_1,wd_1_1,theta2.diff(),theta2.diff().diff())
wd_3_3 = ir.get_angular_acc_R(T23,w_2_2,wd_2_2,0,0)

v_0_0 = sympy.Matrix([[0],[0],[0]])
v_1_1 = ir.get_linear_vel_R(T01,w_0_0,v_0_0)
v_2_2 = ir.get_linear_vel_R(T12,w_1_1,v_1_1)
v_3_3 = ir.get_linear_vel_R(T23,w_2_2,v_2_2)
vd_0_0 = sympy.Matrix([[0],[0],[0]])
vd_1_1 = ir.get_linear_acc_R(T01,w_0_0,wd_0_0,vd_0_0)
vd_2_2 = ir.get_linear_acc_R(T12,w_1_1,wd_1_1,vd_1_1)
vd_3_3 = ir.get_linear_acc_R(T23,w_2_2,wd_2_2,vd_2_2)

r_1_G1 = sympy.Matrix([[l1g],[0],[0]])
r_2_G2 = sympy.Matrix([[l2g],[0],[0]])
vd_1_G1 = ir.get_com_acc(vd_1_1,w_1_1,wd_1_1,r_1_G1)
vd_2_G2 = ir.get_com_acc(vd_2_2,w_2_2,wd_2_2,r_2_G2)

# Netwon-Euler Method. 2. Inverse Iteration

g = sympy.symbols('g')

f_3_3 = sympy.Matrix([[0],[0],[0]])
n_3_3 = sympy.Matrix([[0],[0],[0]])
g_0 = sympy.Matrix([[0],[0],[-g]])

f_2_2 = ir.get_dynamics_force_i(T23,T01@T12,m2,g_0,vd_2_G2,f_3_3)
f_1_1 = ir.get_dynamics_force_i(T12,T01,m1,g_0,vd_1_G1,f_2_2)

Ixx1,Iyy1,Izz1,Ixx2,Iyy2,Izz2 = sympy.symbols('Ixx1,Iyy1,Izz1,Ixx2,Iyy2,Izz2')
I_1_G1 = sympy.Matrix([[Ixx1,0,0],[0,Iyy1,0],[0,0,Izz1]])
I_2_G2 = sympy.Matrix([[Ixx2,0,0],[0,Iyy2,0],[0,0,Izz2]])
n_2_2 = ir.get_dynamics_torque_i(T23,n_3_3,f_2_2,f_3_3,w_2_2,wd_2_2,r_2_G2,I_2_G2)
n_1_1 = ir.get_dynamics_torque_i(T12,n_2_2,f_1_1,f_2_2,w_1_1,wd_1_1,r_1_G1,I_1_G1)

tau = sympy.Matrix([[n_1_1[2]],[n_2_2[2]]])

qdd = sympy.Matrix([[theta1.diff().diff()],[theta2.diff().diff()]])
M_ne, C_ne, G_ne = ir.get_EoM_from_T(tau,qdd,g)

M_ne

C_ne

G_ne

# Lagrangian Method

w_0_0 = sympy.Matrix([[0],[0],[0]])
w_1_1 = ir.get_angular_vel_R(T01,w_0_0,theta1.diff())
w_2_2 = ir.get_angular_vel_R(T12,w_1_1,theta2.diff())
w_3_3 = ir.get_angular_vel_R(T23,w_2_2,0)

w_1_1,w_2_2,w_3_3

v_0_0 = sympy.Matrix([[0],[0],[0]])
v_1_1 = ir.get_linear_vel_R(T01,w_0_0,v_0_0)
v_2_2 = ir.get_linear_vel_R(T12,w_1_1,v_1_1)
v_3_3 = ir.get_linear_vel_R(T23,w_2_2,v_2_2)

v_1_1,v_2_2,v_3_3

r_1_G1 = sympy.Matrix([[l1g],[0],[0]])
r_2_G2 = sympy.Matrix([[l2g],[0],[0]])
v_1_G1 = ir.get_com_vel(v_1_1,w_1_1,r_1_G1)
v_2_G2 = ir.get_com_vel(v_2_2,w_2_2,r_2_G2)

v_1_G1,v_2_G2

Ixx1,Iyy1,Izz1,Ixx2,Iyy2,Izz2 = sympy.symbols('Ixx1,Iyy1,Izz1,Ixx2,Iyy2,Izz2')
I_1_G1 = sympy.Matrix([[Ixx1,0,0],[0,Iyy1,0],[0,0,Izz1]])
I_2_G2 = sympy.Matrix([[Ixx2,0,0],[0,Iyy2,0],[0,0,Izz2]])
T = ir.get_kinectic_energy(m1,v_1_G1,I_1_G1,w_1_1) + ir.get_kinectic_energy(m2,v_2_G2,I_2_G2,w_2_2)

T

g = sympy.symbols('g')

g_0 = sympy.Matrix([[0],[0],[-g]])

T02 = T01*T12
V = ir.get_potential_energy(T01,m1,g_0,r_1_G1) + ir.get_potential_energy(T02,m2,g_0,r_2_G2)

V

L = ir.get_lagrangian(T,V)

L

q = sympy.Matrix([[theta1],[theta2]])
qd = sympy.Matrix([[theta1.diff()],[theta2.diff()]])
tau = ir.get_torque_from_L(L,q,qd)

# Get Equation of Motion

tau

qdd = sympy.Matrix([[theta1.diff().diff()],[theta2.diff().diff()]])
M_l, C_l, G_l = ir.get_EoM_from_T(tau,qdd,g)

M_l

C_l

G_l

# Check that the results of Newton-Euler and Lagrangian are same.
sympy.simplify(M_ne - M_l)

Gamma, C_christ = ir.get_Christoffel_term(M_l,q,qd)

# Chistoffel Symbol
C_christ, C_l